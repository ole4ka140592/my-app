//Обычно, когда вы что-то покупаете, вас спрашивают, верны ли номер вашей кредитной карты, номер телефона или ответ на ваш самый секретный вопрос. Однако, поскольку кто-то может заглянуть вам через плечо, вы не хотите, чтобы это отображалось на вашем экране. Вместо этого мы маскируем его. Ваша задача — написать функцию maskify, которая заменяет все символы, кроме последних четырех, на «#».
function maskify(cc) {
    if (cc.length <= 4) {
        return cc
    }
    if (cc.length > 4) {
        let result = ''
        let last = cc.substr(-4)
        for (let i = 0; i < cc.length - 4; i++) {
            result += '#'
        }
        return result + last
    }
}


//Нет истории Нет описания Только подумав и проверив Посмотрите на результат теста, угадайте код!
// Серии:
// 01: А и Б?
// 02: неполная строка
// 03: правда или ложь
// 04: Что-то с большой буквы
// 05: Уникальный или не уникальный
// 06: Пространственно-временной индекс
// 07: Математика начальной школы
// 08: Математика средней школы
// 09: Из небытия В ничто
// 10: Не идеально? Выбрасывать!
// 11: Добро пожаловать на автобус
// 12: Придет счастливый день
// 13: Сумма 15 (Хету Луослиу)
// 14: Туманность или Вихрь
// 15: Звезда спорта
// 16: Рэп-концерт фальцетто
// 17: Ветер шепчет
// 18: Симулятор мобильного телефона
// 19: Присоединяйтесь, но не присоединяйтесь
// 20: Я ненавижу больших и маленьких
// 21: Я хочу стать диабетиком ;-)
// 22: Сколько блоков?
// 23: Оператор скрыт в строке
// 24: Магия подстроки
// 25: Сообщить о чем-то
// 26: Удержание и сброс I
// 27: Удержание и отбраковка II
// 28: Сколько "слов"?
// 29: Град и водопад
// 30: Любовь навсегда
// 31: Цифровой бассейн
// 32: Соревнования по стрельбе из лука
// 33: Ремонт пергамента
// 34: Кто ты?
// 35: Безопасное положение
// Специальная рекомендация
// Еще одна серия, новаторская и интересная, средней сложности. Те, кто любит бросать вызов, могут попробовать эти ката: Играть в тетрис: формировать анастомоз
// Играть во FlappyBird: вперед смело
function testit(a, b) {
    return a | b;
}


//Просто, учитывая строку слов, вернуть длину кратчайшего слова (слов). Строка никогда не будет пустой, и вам не нужно учитывать разные типы данных.
function findShort(s) {
    let arr = s.split(" ").sort((a, b) => a.length - b.length);
    return arr[0].length
}


//Возьмите 2 строки s1 и s2, содержащие только буквы от a до z. Возвращает новую отсортированную строку, максимально длинную, содержащую различные буквы (каждая из которых взята только один раз) из s1 или s2.
function longest(s1, s2) {
    let a = (s1 + s2).split('').sort()
    return [...new Set(a)].join('')
}


//Возвращает количество (количество) гласных в заданной строке. Мы будем рассматривать a, e, i, o, u как гласные для этой Ката (но не y). Входная строка будет состоять только из строчных букв и/или пробелов.
function getCount(str) {
    let vowelsCount = 0
    const vowels = ["a", "e", "i", "o", "u"]
    for (let char of str) {
        if (vowels.includes(char)) {
            vowelsCount++
        }
    }
    return vowelsCount;
}


//Завершите решение так, чтобы оно возвращало true, если первый переданный аргумент (строка) заканчивается вторым аргументом (тоже строкой). Примеры:
//solution('abc', 'bc') // returns true
//solution('abc', 'd') // returns false
function solution(str, ending) {
    return str.endsWith(ending)
}


//Помогите Сузуки разгрести его огород! В монастыре есть великолепный дзен-сад из белого гравия и камней, который каждый день усердно расчищают монахи. Suzuki, обладающий острым зрением, всегда высматривает все, что может проникнуть в сад, что необходимо удалить во время ежедневного сгребания, например, насекомых или мох. Вам будет предоставлена -строка, представляющая сад, например: сад = 'гравий гравий гравий гравий гравий гравий гравий гравий каменный слизняк муравей гравий гравий улитка гравий гравий гравий гравий гравий гравий гравий гравий слизень гравий муравей гравий гравий гравий гравий каменный слизняк гравий гравий гравий гравий гравий улитка гравий гравий камень гравий улитка гравий слизняк гравий паук гравий гравий гравий гравий гравий гравий гравий мох гравий гравий гравий улитка гравий гравий гравий муравьиный гравий гравий мох гравий гравий гравий гравий улитка гравий гравий гравий гравий пуля гравий камень гравий гравий камень гравий гравий гравий гравий улитка гравий камень гравий гравий гравий гравий гравий гравий паук гравий каменный гравий гравий'
// Выгребите все предметы, не являющиеся камнями или гравием, и замените их гравием таким образом, чтобы://
// сад = 'паук-слизень каменный гравий гравий гравий гравий гравий гравий гравий гравий'
// Возвращает строку, в которой все элементы, кроме камня или гравия, заменены гравием://
// сад = 'гравий гравий камень гравий гравий гравий гравий гравий гравий гравий гравий'
// Пожалуйста, попробуйте и другие Ката из этой серии.
// Помогите Сузуки сосчитать овощи...
// Помогите Судзуки купить тофу!
// Помоги Сузуки упаковать корзину с углем!
// Судзуки нужна помощь, чтобы собрать своих учеников!
// Сколько ступеней поднимется Сузуки за 20 лет?
function rakeGarden(garden) {
    var rakedGarden = garden.split(' ').map(value => value == 'rock' ? 'rock' : 'gravel').join(' ')
    return rakedGarden;
}


//Мой дедушка всегда предсказывал, как стареют люди, и прямо перед смертью раскрыл свой секрет! В честь памяти моего дедушки мы напишем функцию по его формуле! Составьте список возрастов, когда каждый из ваших прадедов умер. Умножьте каждое число само на себя. Добавьте их все вместе. Возьмите квадратный корень из результата.
// Разделить на два.
// Пример PredictAge(65, 60, 75, 55, 60, 63, 64, 45) === 86
// Примечание: результат следует округлить до ближайшего целого числа в меньшую сторону. Некоторые случайные тесты могут не пройти из-за ошибки в реализации JavaScript. Просто отправьте повторно, если это произойдет с вами
function predictAge(age1, age2, age3, age4, age5, age6, age7, age8) {
    const ages = [age1, age2, age3, age4, age5, age6, age7, age8];
    const mulSum = ages.reduce((a, x) => a + x ** 2, 0);
    return Math.floor(mulSum ** 0.5 / 2);
}


//Вам будет предоставлен массив и предельное значение. Вы должны убедиться, что все значения в массиве ниже или равны предельному значению. Если они есть, верните true. В противном случае верните ложь.
function smallEnough(a, limit) {
    a.sort((a, b) => b - a)
    let max = a[0]
    if (max <= limit) {
        return true
    } else {
        return false
    }
}


//Изограмма — это слово, в котором нет повторяющихся букв, последовательных или непоследовательных. Реализуйте функцию, определяющую, является ли строка, содержащая только буквы, изограммой. Предположим, что пустая строка является изограммой. Игнорировать регистр букв. Пример: (Ввод --> Вывод) "Дерматоглифика" --> правда "аба" --> ложь "moOse" --> false (игнорировать регистр букв)
function isIsogram(str) {
    var i, j;
    str = str.toLowerCase();
    for (i = 0; i < str.length; ++i) {
        for (j = i + 1; j < str.length; ++j) {
            if (str[i] === str[j]) {
                return false;
            }
        }
    }
    return true;
}


//Ваши коллеги были достаточно любезны (?), чтобы купить вам подарок на день рождения. Несмотря на то, что это ваш день рождения, а не их, они решили сыграть с ним в передачу посылки, чтобы у всех были равные шансы на победу. Подарков много, один получишь, но не все хороши... Один даже взрывается и засыпает тебя землей... странный офис. В качестве компенсации за этот подарок — собака! Счастливые дни! (не покупайте собак в подарок, а если и покупаете, то никогда их не заворачивайте). В зависимости от количества проходов в игре (y) и подарка, который вы разворачиваете (x), вернитесь следующим образом:
// x == goodpresent --> вернуть x с количеством проходов, добавленных к каждому charCode (перейти к charCode, добавить y к каждому, повернуть назад)
// х == дерьмо || x == пусто --> возвращаемая строка, отсортированная по алфавиту
// x == bang --> возвращаемая строка преобразуется в коды символов, каждый код уменьшается на количество проходов и суммируется до одной цифры
// x == badpresent --> return 'Возьмите это обратно!'
// x == собака, вернуть 'упасть в обморок от волнения y раз' (где y - значение, заданное для y).
function present(x, y) {
    if (x === 'badpresent') return 'Take this back!'
    if (x === 'dog') return `pass out from excitement ${y} times`
    if (x === 'crap') return 'acpr'
    if (x === 'empty') return 'empty'
    if (x === 'bang') return x.split('').reduce((a, b) => a + (b.charCodeAt() - y), 0)
    return x.split('').map(v => String.fromCharCode(v.charCodeAt() + y)).join('')
}


//Определите общее количество цифр в целом числе (n>=0), заданном в качестве входных данных для функции. Например, 9 — это одна цифра, 66 — 2 цифры, а 128685 — 6 цифр. Будьте осторожны, чтобы избежать переполнения/недостаточного заполнения. Все входы будут действительными.
function digits(n) {
    return ('' + n).length
}


//Завершите решение так, чтобы оно перевернуло переданную в него строку. 'мир' => 'длроу' 'слово' => 'дроу'
function solution(str) {
    return str.split("").reverse().join("")
}


//Напишите функцию reverseList, которая просто переворачивает списки.
function reverseList(arr) {
    return arr.reverse();
}


//Измените функцию spacify, чтобы она возвращала заданную строку с пробелами, вставленными между каждым символом. spacify("привет мир") // возвращает "привет мир"
function spacify(str) {
    return str.split('').join(' ')
}


//Возможно, вы знаете несколько довольно больших идеальных квадратов. Но как насчет СЛЕДУЮЩЕГО? Завершите метод findNextSquare, который находит следующий целочисленный идеальный квадрат после квадрата, переданного в качестве параметра. Напомним, что целочисленный совершенный квадрат — это целое число n, такое что sqrt(n) также является целым числом. Если параметр сам по себе не является идеальным квадратом, то следует вернуть -1. Вы можете предположить, что параметр неотрицательный.
function findNextSquare(sq) {
    var root1;
    var nextroot;
    if (Math.sqrt(sq) % 1 === 0) {
        root1 = Math.sqrt(sq)
        nextroot = root1 + 1
    } else {
        return -1;
    }
    return nextroot * nextroot;
}


//Напишите функцию, которая принимает строку и делает из нее аббревиатуру. Правило составления аббревиатуры в этой ката: разделить строку на слова пробелом взять каждую первую букву слова в заданной строке прописные это присоединиться к ним вместе Например: Кодовые войны -> C, w -> C W -> CW Примечание. В заданной строке будет не менее двух слов!
function toAcronym(inp) {
    return inp.split(' ').map(m => m[0].toUpperCase()).join('')
}


//Добро пожаловать. В этой ката вас просят возвести в квадрат каждую цифру числа и соединить их. Например, если мы пропустим через функцию 9119, получится 811181, потому что 92 — это 81, а 12 — это 1. Примечание. Функция принимает целое число и возвращает целое число.
function squareDigits(num) {
    return +(num.toString().split("").map(m => m * m).join(""))
}


//Напишите программу, которая определяет, содержит ли строка только уникальные символы. Возвращает true, если это так, и false в противном случае. Строка может содержать любой из 128 символов ASCII. Символы чувствительны к регистру, например. 'a' и 'A' считаются разными символами.
function hasUniqueChars(str) {
    return new Set(str).size === str.length
}


//Завершите функцию/метод, чтобы он возвращал URL-адрес с чем-либо после удаления привязки (#) Examples
//"www.codewars.com#about" --> "www.codewars.com"
//"www.codewars.com?page=1" -->"www.codewars.com?page=1
function removeUrlAnchor(url) {
    if (arguments.length !== 1) {
        throw new Error("expected exactly one argument");
    }
    if (typeof url !== "string") {
        throw new TypeError("expect first argument to be a string");
    }
    if (url.length === 0) {
        return "";
    }
    const [character, ...remainingUrl] = url;
    if (character === "#") {
        return "";
    }
    return character + removeUrlAnchor(remainingUrl.join(""));
}


//Ваша задача — написать функцию factorial
function factorial(n) {
    return n ? n * factorial(n - 1) : 1
}


//В математике факториал неотрицательного целого числа n, обозначаемый n!, представляет собой произведение всех положительных целых чисел, меньших или равных n. Например: 5! = 5 * 4 * 3 * 2 * 1 = 120. По соглашению значение 0! 1. Напишите функцию для вычисления факториала для заданных входных данных. Если входное значение меньше 0 или больше 12, генерируется исключение типа ArgumentOutOfRangeException (C#), IllegalArgumentException (Java) или RangeException (PHP), либо генерируется ошибка RangeError (JavaScript) или ValueError (Python), либо возвращается -1 (C). Подробнее о факториале можно узнать здесь.
function factorial(n) {
    if (n < 0 || n > 12) {
        throw new RangeError
    }
    return n ? n * factorial(n - 1) : 1
}


//Представьте себе два кольца с цифрами на них. Внутреннее кольцо вращается по часовой стрелке (уменьшая на 1 каждый оборот), а внешнее кольцо вращается против часовой стрелки (увеличивая на 1 каждый оборот). Мы начинаем с обоих колец, выровненных по 0 вверху, и на каждом ходу мы вращаем каждое кольцо на одно приращение. Сколько ходов потребуется, прежде чем на обоих кольцах снова появится одно и то же число?
//
// Внутреннее кольцо имеет целые числа от 0 до innerMax, а внешнее кольцо имеет целые числа от 0 до externalMax, где innerMax и externalMax — целые числа >= 1.
//
// например если innerMax равно 2, а externalMax равно 3, то после
// 1 ход: внутренний = 2, внешний = 1
// 2 хода: внутренний = 1, внешний = 2
// 3 хода: внутренний = 0, внешний = 3
// 4 хода: внутренний = 2, внешний = 0
// 5 ходов: внутренний = 1, внешний = 1
// Поэтому требуется 5 ходов, чтобы два кольца достигли одинакового числа.
// Поэтому spinningRings(2, 3) = 5
// например если innerMax равно 3, а externalMax равно 2, то после
// 1 ход: внутренний = 3, внешний = 1
// 2 хода: внутренний = 2, внешний = 2
// Поэтому требуется 2 хода, чтобы два кольца достигли одинакового числа.
// спиннингрингс(3, 2) = 2
function spinningRings(innerMax, outerMax) {
    for(var i = 1; innerMax - ((i - 1) % (innerMax + 1)) !== i % (outerMax + 1); i++) {}
    return i;
}


//Переместите каждую букву в предоставленной строке вперед на 10 букв по алфавиту.
// Если он идет дальше «z», начните снова с «a».
// Ввод будет строкой длины > 0.
function moveTen(s){
    const str='abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz';
    const arr=s.split('').map(v=>v=str.indexOf(v)+10)
    return arr.map(v=>v=str[v]).join('')
}


//Фон
// Вы моделируете взаимодействие между большим количеством кварков и решили создать класс Quark, чтобы вы могли генерировать свои собственные объекты кварков.
// Кварки — это фундаментальные частицы и единственная фундаментальная частица, на которую действуют все четыре фундаментальные силы.
// Твое задание
// Ваш класс Quark должен позволять создавать кварки любого допустимого цвета («красный», «синий» и «зеленый») и любого допустимого вкуса («верхний», «нижний», «странный», «очаровательный», «верхний»). ", "низ").
// Каждый кварк имеет одинаковое baryon_number (BaryonNumber в C#): 1/3.
// У каждого кварка должен быть метод .interact() (.Interact() в C#), который позволяет любому кварку взаимодействовать с другим кварком посредством сильного взаимодействия. Когда два кварка взаимодействуют, они меняют цвет.//
// Пример
// >>> q1 = Quark("красный", "вверх")
// >>> q1.цвет
// "красный"
// >>> q1.вкус
// "вверх"
// >>> q2 = Quark("синий", "странный")
// >>> q2.цвет
// "синий"
// >>> q2.baryon_number
// 0,33333333333333333
// >>> q1.interact(q2)
// >>> q1.цвет
// "синий"
// >>> q2.цвет
// "красный"
class Quark{
    constructor(color,flavor){
        this.color=color;
        this.flavor=flavor
        this.baryon_number=1/3
    }
    interact(obj){
        const color1 = obj.color;
        const color2 = this.color;
        this.color = color1;
        obj.color = color2;
    };
}


//О, нет! Сообщается, что призраки заполонили город. Это ваша работа, чтобы избавиться от них и спасти день! В этой ката строки представляют собой здания, а пробелы внутри этих строк представляют собой призраков. Так чего же ты ждешь? Вернуть здание(строка) без привидений(пробелов)!
// Пример:
// GhostBusters("Очистить небо");
// Должен вернуться:
// "Небоскреб"
// Если в здании нет призраков, вернуть строку:
// "Ты просто хотел мой автограф, не так ли?"
function ghostBusters(building) {
    if(building.match(/ /)) {
        return building.split(" ").reduce((a,b)=>a+b)
    }
    return "You just wanted my autograph didn't you?"
}


//Учитывая массив чисел, вернуть новый массив длины number, содержащий последние четные числа из исходного массива (в том же порядке). Исходный массив не будет пустым и будет содержать не менее "числа" четных чисел.
// Например:
//For example: ([1, 2, 3, 4, 5, 6, 7, 8, 9], 3) => [4, 6, 8]
//([-22, 5, 3, 11, 26, -6, -7, -8, -9, -8, 26], 2) => [-8, 26]
//([6, -25, 3, 7, 5, 5, 7, -3, 23], 1) => [6]
function evenNumbers(array, number) {
    // good luck
    return array.filter(v=>v%2==0).slice(-number)
}


//Площадь стрелки
// Стрелка образуется в прямоугольнике со сторонами a и b путем соединения нижних углов с серединой верхнего края и центром прямоугольника. стрелка a и b являются целыми числами и > 0. Напишите функцию, которая возвращает площадь стрелки.
function arrowArea(a,b) {
    return (a*b/4).toFixed(2)*1
}


//На этот раз ни истории, ни теории. В приведенных ниже примерах показано, как написать функцию accum:
// Примеры:
// accum("abcd") -> "A-Bb-Ccc-Dddd"
// accum("RqaEzty") -> "R-Qq-Aaa-Eeee-Zzzzz-Ttttt-Yyyyyyy"
// accum("cwAt") -> "C-Ww-Aaa-Tttt"
// Параметр accum представляет собой строку, включающую только буквы из a..z и A..Z.
function accum(s) {
    return s.split('')
        .map((c, i) => (c.toUpperCase() + c.toLowerCase()
            .repeat(i)))
        .join('-');
}


//Учитывая массив чисел (в строковом формате), вы должны вернуть строку. Цифры соответствуют буквам алфавита в обратном порядке: a=26, z=1 и т. д. Также следует учитывать '!', '?' и ' ', которые представлены как '27', '28' и '29' соответственно. Все входы будут действительными.
function switcher(x){
    let alpha = ' zyxwvutsrqponmlkjihgfedcba!? '
    return x.map( v=>alpha[v]).join('')
}


//Цвет играет важную роль в нашей жизни. Большинству из нас этот цвет нравится больше, чем другой. Специалисты по пользовательскому опыту считают, что определенные цвета имеют для нас определенное психологическое значение.Вам дан двумерный массив, состоящий из цвета и его «общей» ассоциации в каждом элементе массива. Функция, которую вы напишете, должна возвращать цвет как «ключ» и ассоциацию как «значение».
// Например:
//var array = [["white", "goodness"], ...] //returns [{white: 'goodness'}, ...]
function colourAssociation(array){
    return array.map(([colour, association]) => ({[colour]:association}))
}